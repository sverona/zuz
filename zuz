#!/bin/sh

sort_string() {
  printf "$1" | tr '[a-z]' '[A-Z]' | grep -o . | sort -n | tr -d '\n'
}

seq_() {
  min=$1
  max=${2:$1}
  inc=${3:- 1}
  bc -l <<< "for (i = $min; i <= $max; i+=$inc) i"
}

throw() {
  printf "%s: %s\n" "$0" "$1" >&2
  exit $2
}

range() {
  case "$1" in
    *,*)
      IFS=,
      set -f
      limits=($1)
      set +f
      unset IFS

      return "$limits"
    ;;
    *-*) 
      IFS=-
      set -f
      limits=($1)
      set +f
      unset IFS

      if [ ${#limits[@]} > 2 ]; then
        throw "bad range '$1'" 1
      fi

      return "$(seq_ limits[0] limits[1])"
    ;;
    *)
      throw "bad range '$1'" 1
    ;;
  esac
}

# Use ripgrep if installed for speed
GREP=""
for g in rg ag ack grep; do
  if which $g >/dev/null 2>/dev/null; then
    GREP=$g
    break
  fi
done
if [ ! "$GREP" ]; then
  throw "no grep installed" 1
fi

# Parse options.
OPTS=`getopt -o 23456789aesd:l:v:V:c:C:p:P: -l anagram,exact,pattern,subanagram,dict:,dictionary:,length:,vowels:,pct-vowels:,consonants:,pct-consonants:,probability-order:,playability-order:,point-value: -- "$@"`
if [ $? != 0 ]; then
  throw "could not parse options" 1
fi
eval set -- "$OPTS"

ANAGRAM=true
EXACT=false
SUBANAGRAM=false
DICT="$(realpath $(dirname $0)/dicts/NWL2018.tsv)"
LENGTH=
VOWELS=
CONSONANTS=
PCT_VOWELS=
PCT_CONSONANTS=
PROBABILITY_ORDER=
PLAYABILITY_ORDER=
POINT_VALUE=
PATTERN=

while true; do
  case "$1" in
    -2 ) LENGTH=2; shift;;
    -3 ) LENGTH=3; shift;;
    -4 ) LENGTH=4; shift;;
    -5 ) LENGTH=5; shift;;
    -6 ) LENGTH=6; shift;;
    -7 ) LENGTH=7; shift;;
    -8 ) LENGTH=8; shift;;
    -9 ) LENGTH=9; shift;;

    -a | --anagram )
      ANAGRAM=true; EXACT=false; SUBANAGRAM=false; shift;;
    -e | --exact | --pattern )
      ANAGRAM=false; EXACT=true; SUBANAGRAM=false; shift;;
    -s | --subanagram )
      ANAGRAM=false; EXACT=false; SUBANAGRAM=true; shift;;

    -d | --dict | --dictionary ) DICT="$2"; shift 2;;
    -l | --length ) LENGTH="$(range $2)"; shift 2;;
    -v | --vowels ) VOWELS="$(range $2)"; shift 2;;
    -c | --consonants ) CONSONANTS="$(range $2)"; shift 2;;
    -V | --pct-vowels ) PCT_VOWELS="$(range $2)"; shift 2;;
    -C | --pct-consonants ) PCT_CONSONANTS="$(range $2)"; shift 2;;
    -p | --probability-order ) PROBABILITY_ORDER="$(range $2)"; shift 2;;
    -P | --playability-order ) PLAYABILITY_ORDER="$(range $2)"; shift 2;;
    --point-value ) POINT_VALUE="$(range $2)"; shift 2;;

    --) PATTERN="$2"; break;;
    -*) throw "bad option $1" 1; break;;
    *) PATTERN="$1"; break;;
  esac
done

if $EXACT; then
  regex="$(printf $PATTERN | tr '[a-z]' '[A-Z]')"
  regex="$(printf $regex | sed -e 's/?/[A-Z]/g' -e 's/*/[A-Z]*/g' -e 's/.*/\\b&\\b/')"
elif $ANAGRAM; then
  regex="$(sort_string $PATTERN |  )"
elif $SUBANAGRAM; then
  regex="$(sort_string $PATTERN | sed -e 's/./&[A-Z]*/g' -e 's/^/^[A-Z]*/')"
fi

printf '%s\n' "$regex"

flags=''
if [ $GREP == 'rg' ]; then
  flags='--no-line-number'
elif [ $GREP == 'ag' ]; then
  flags='--nonumbers'
fi

$GREP $flags $regex $DICT
